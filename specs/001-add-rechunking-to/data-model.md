# Data Model: Add Rechunking to Reduce Update Sizes

**Feature**: Add Rechunking to Reduce Update Sizes  
**Date**: 2025-10-11  
**Context**: GitHub Actions workflow modification (no traditional application data model)

## Overview

This feature modifies a CI/CD pipeline rather than creating traditional application entities. The "data model" consists of workflow artifacts, GitHub Actions context, and OCI image metadata flowing through the rechunking pipeline.

## Entities

### Entity 1: OCI Image (Pre-Rechunking)

**Description**: Container image built by Podman/Build ah during GitHub Actions workflow execution, before rechunking optimization is applied.

**Attributes**:
- `ref` (string, required): Local image reference, format: `localhost/bazzite-dkub:<tag>`
  - Example: `localhost/bazzite-dkub:40-20251011`
  - Generated by: Build step in workflow
  - Validation: Must exist in local Podman storage
- `layers` (array of layer objects, computed): OCI layers comprising the image
  - Each layer: `{digest: string, size: number, mediaType: string}`
  - Typically 30-50 layers for bazzite-dkub
  - Unoptimized for delta downloads
- `size_bytes` (number, computed): Total size of all layers
  - Typical range: 8-10 GB uncompressed
  - Measured via: `podman inspect --format='{{.Size}}'`
- `labels` (object, required): OCI metadata labels from docker/metadata-action
  - Must include: `org.opencontainers.image.version`, `org.opencontainers.image.title`, `io.github-actions.build.url`
  - Format: JSON object of key-value string pairs
- `manifest_digest` (string, computed): SHA256 digest of image manifest
  - Format: `sha256:<64-char-hex>`
  - Used for: Image verification and referencing

**State Transitions**:
1. **Building**: Containerfile execution in progress
2. **Built**: Image available in local Podman storage
3. **Ready for Rechunking**: Tagged and awaiting rechunking step
4. **Consumed**: Passed to rechunking action (ephemeral, replaced by rechunked version)

**Relationships**:
- **Input to**: Rechunking Process (Entity 4 conceptual process)
- **Produces**: OCI Image (Post-Rechunking) via rechunking transformation
- **References**: Base Image (`ghcr.io/ublue-os/bazzite-dx:stable`)

**Validation Rules**:
- Image must be buildable on GitHub Actions ubuntu-latest runner
- Image must pass `bootc container lint` validation
- Image must include all required OCI labels
- Total size must be <15 GB (GitHub Actions storage constraint)

**Lifecycle**:
- **Created**: During "Build Image" workflow step
- **Exists**: Until workflow completes (ephemeral)
- **Destroyed**: GitHub Actions runner cleanup (automatic)

---

### Entity 2: OCI Image (Post-Rechunking)

**Description**: Optimized container image produced by hhd-dev/rechunk action with layer chunking applied for efficient delta downloads.

**Attributes**:
- `ref` (string, required): Rechunked image reference from rechunk action output
  - Example: `oci:/var/tmp/rechunk-output/bazzite-dkub`
  - Generated by: hhd-dev/rechunk action
  - Temporary OCI directory format
- `chunks` (number, computed): Number of optimized chunks created
  - Typical range: 7-10 chunks (CLARIFICATION: informational target, not enforced)
  - Exposed via: OCI label `rechunk.chunks`
  - Indicates rechunking granularity
- `prev_ref_used` (string, nullable): Previous reference used for incremental optimization
  - Example: `ghcr.io/dkolb/bazzite-dkub:40-20251010`
  - Empty if fresh rechunking mode
  - Exposed via: OCI label `rechunk.prev-ref`
- `rechunk_version` (string, required): Version of hhd-dev/rechunk action used
  - Example: `v1.2.4`
  - Exposed via: OCI label `rechunk.version`
  - For troubleshooting and compatibility tracking
- `labels` (object, required): All OCI labels (preserved from pre-rechunk + rechunk metadata)
  - Superset of pre-rechunk labels
  - Additional labels: `rechunk.*` namespace
- `optimized_layers` (array of layer objects, computed): Rechunked OCI layers
  - Structured for minimal delta downloads
  - Layer count may differ from pre-rechunk (chunk boundaries realigned)

**State Transitions**:
1. **Rechunking**: hhd-dev/rechunk action processing
2. **Rechunked**: Output written to OCI directory
3. **Loaded**: Pulled into Podman storage and tagged
4. **Published**: Pushed to GHCR with all tags

**Relationships**:
- **Derived from**: OCI Image (Pre-Rechunking) + Previous Reference
- **Tagged as**: Multiple tags from metadata step (e.g., `latest`, `40`, `40-20251011`)
- **Signed by**: Cosign (creates signature in GHCR)
- **Consumed by**: End users via rpm-ostree upgrade

**Validation Rules**:
- Must include `rechunk.version` label
- Must include `rechunk.chunks` label (positive integer)
- Chunk count typically 7-10 (informational validation, not blocking)
- If incremental mode, must include `rechunk.prev-ref` label
- Must be signable by Cosign (OCI-compliant manifest)
- Must be bootable when deployed to OSTree system

**Lifecycle**:
- **Created**: During "Run Rechunker" workflow step
- **Loaded**: During "Load rechunked image" step (pulled into Podman)
- **Published**: During "Push to GHCR" step
- **Persists**: In GHCR indefinitely (CLARIFICATION: keep all tags)

**Performance Characteristics**:
- Initial download size: Similar to pre-rechunk (~8-10 GB)
- Delta download size: 80-95% smaller for minor changes (200-400 MB vs. 2 GB)
- Rechunking time: 2-7 minutes depending on fresh vs. incremental mode

---

### Entity 3: Previous Reference (prev-ref)

**Description**: Reference to the latest published rechunked image in GHCR, used as baseline for incremental rechunking optimization.

**Attributes**:
- `tag` (string, nullable): Tag of previous rechunked image
  - Format: `40-YYYYMMDD` (8 digits: Fedora 40 + 4-digit year + 2-digit month + 2-digit day)
  - Example: `40-20251010`
  - Pattern validation: `^40-[0-9]{8}$`
  - Empty if: No previous tags exist OR fresh-rechunk mode enabled OR current tag matches latest
- `ref` (string, nullable): Full image reference for rechunking action
  - Format: `ghcr.io/dkolb/bazzite-dkub:<tag>`
  - Example: `ghcr.io/dkolb/bazzite-dkub:40-20251010`
  - Empty if `tag` is empty
- `generation_method` (enum, constant): Method used to determine prev-ref
  - Value: `"ghcr_query"` (CLARIFICATION: query GHCR, not date arithmetic)
  - Alternative rejected: `"date_arithmetic"` (brittle for irregular schedules)
- `query_timestamp` (ISO 8601 string, computed): When GHCR was queried for latest tag
  - Example: `2025-10-11T14:30:00Z`
  - For debugging query race conditions

**State Transitions**:
1. **Querying**: `skopeo list-tags` in progress
2. **Resolved**: Tag found and validated
3. **Empty**: No valid tag found (first build, fresh mode, or same-day rebuild)
4. **Used**: Passed to rechunking action as `prev-ref` input

**Relationships**:
- **References**: OCI Image (Post-Rechunking) from previous build
- **Input to**: Rechunking Process (hhd-dev/rechunk action)
- **Determined by**: GHCR Tag Query Algorithm

**GHCR Query Algorithm** (CLARIFICATION from research Decision 5):
```bash
# Skip if fresh-rechunk mode
if [[ "${{ github.event.inputs.fresh-rechunk }}" == "true" ]]; then
  prev_ref=""  # Empty → fresh rechunking
  exit 0
fi

# Query GHCR for all tags
ALL_TAGS=$(skopeo list-tags docker://ghcr.io/dkolb/bazzite-dkub 2>/dev/null)

# Filter for Fedora 40 date tags, sort lexicographically, take last
LATEST_TAG=$(echo "$ALL_TAGS" | jq -r '.Tags | map(select(test("^40-[0-9]{8}$"))) | sort | last // ""')

# Validate tag exists and differs from current build tag
CURRENT_TAG="${{ steps.generate-version.outputs.tag }}"
if [[ -n "$LATEST_TAG" ]] && [[ "$LATEST_TAG" != "$CURRENT_TAG" ]]; then
  prev_ref="ghcr.io/dkolb/bazzite-dkub:$LATEST_TAG"
else
  prev_ref=""  # No valid prev-ref → fresh rechunking
fi
```

**Edge Cases**:
- **First rechunked build**: No tags match pattern → `prev_ref=""` → fresh rechunking
- **Same-day rebuild**: `LATEST_TAG == CURRENT_TAG` → `prev_ref=""` → fresh rechunking (prevents circular reference)
- **GHCR query failure**: `skopeo` returns error → `prev_ref=""` → fresh rechunking (safe fallback)
- **Concurrent builds** (CLARIFICATION): Race condition accepted. Worst case: one build uses slightly stale prev-ref, still produces valid image.
- **Deleted tags**: Tag referenced in previous build now deleted → Query returns different tag or empty → Workflow continues with best available or fresh mode

**Validation Rules**:
- If not empty, tag must exist in GHCR (verified by skopeo)
- Tag must match pattern `^40-[0-9]{8}$`
- Tag must not equal current build's tag (circular reference prevention)

**Lifecycle**:
- **Generated**: During "Generate Previous Reference" workflow step
- **Exists**: Only during workflow execution (ephemeral step output)
- **Consumed**: By hhd-dev/rechunk action `prev-ref` input parameter

---

### Entity 4: OCI Image Labels

**Description**: Metadata key-value pairs embedded in OCI image manifest, providing traceability, rechunking statistics, and compliance information.

**Standard Labels** (org.opencontainers.image.* namespace):
- `org.opencontainers.image.title` (string, required): "bazzite-dkub"
- `org.opencontainers.image.description` (string, required): Human-readable description
- `org.opencontainers.image.version` (string, required): Matches version tag (e.g., "40-20251011")
- `org.opencontainers.image.url` (string, required): GitHub repository URL
- `org.opencontainers.image.source` (string, required): Source repository URL
- `org.opencontainers.image.revision` (string, required): Git commit SHA
- `org.opencontainers.image.created` (ISO 8601, required): Build timestamp

**GitHub Actions Labels**:
- `io.github-actions.build.url` (string, required): URL to workflow run
  - Example: `https://github.com/dkolb/bazzite-dkub/actions/runs/1234567890`
  - For tracing builds back to CI/CD execution

**Rechunking Metadata Labels**:
- `rechunk.version` (string, required): hhd-dev/rechunk action version
  - Example: `v1.2.4`
  - Indicates rechunking tool version for troubleshooting
- `rechunk.chunks` (string/number, required): Number of chunks created
  - Example: `"7"`
  - Type: String representation of positive integer
  - Typical range: 7-10 (CLARIFICATION: informational, not enforced)
- `rechunk.prev-ref` (string, optional): Previous reference used for incremental optimization
  - Example: `ghcr.io/dkolb/bazzite-dkub:40-20251010`
  - Absent or empty if fresh rechunking mode
  - For debugging chunking decisions

**Relationships**:
- **Attached to**: OCI Image (Post-Rechunking)
- **Generated by**: docker/metadata-action (standard labels) + hhd-dev/rechunk (rechunk labels)
- **Consumed by**: Universal Blue tooling, rpm-ostree, Cosign signing, human operators

**Lifecycle**:
1. **Generated**: Standard labels by metadata-action, rechunk labels by hhd-dev/rechunk
2. **Applied**: Reapplied to rechunked image (hhd-dev/rechunk strips original labels)
3. **Signed**: Included in Cosign signature
4. **Published**: Part of manifest in GHCR
5. **Persists**: Indefinitely with image

**Validation Rules**:
- All required standard labels must be present
- `rechunk.version` must match hhd-dev/rechunk version used in workflow
- `rechunk.chunks` must be parseable as positive integer
- If `rechunk.prev-ref` present, must match image reference format

**Usage**:
```bash
# Inspect labels
skopeo inspect docker://ghcr.io/dkolb/bazzite-dkub:latest | jq '.Labels'

# Verify rechunking applied
skopeo inspect docker://ghcr.io/dkolb/bazzite-dkub:latest | jq '.Labels["rechunk.version"]'

# Check chunk count
skopeo inspect docker://ghcr.io/dkolb/bazzite-dkub:latest | jq '.Labels["rechunk.chunks"]'
```

---

### Entity 5: Workflow Execution Context

**Description**: GitHub Actions runtime environment state, inputs, and secrets required for rechunking workflow execution.

**Attributes**:
- `event_type` (enum): Trigger type for workflow
  - Values: `"push"`, `"workflow_dispatch"`, `"pull_request"`, `"schedule"`
  - Affects behavior: `workflow_dispatch` enables fresh-rechunk parameter
- `fresh_rechunk_input` (boolean, nullable): Manual fresh rechunking mode override
  - Source: `github.event.inputs.fresh-rechunk`
  - Default: `false`
  - Only available for `workflow_dispatch` events
  - If `true`: Skip prev-ref generation, use empty prev-ref
- `branch` (string, required): Git branch being built
  - Example: `"main"`, `"001-add-rechunking-to"`
  - Affects tagging strategy
- `commit_sha` (string, required): Git commit SHA being built
  - Format: 40-character hex string
  - For traceability
- `runner_os` (string, constant): GitHub Actions runner operating system
  - Value: `"Linux"` (ubuntu-latest)
  - Required for: BTRFS support validation
- `runner_disk_space` (number, computed): Available disk space in GB
  - Required: >60 GB (50 GB BTRFS + overhead)
  - Monitored for: BTRFS mount failures

**Secrets** (GitHub repository secrets):
- `GITHUB_TOKEN` (string, required): Automatic token for GHCR access
  - Permissions: Read packages, write packages
  - Used for: skopeo GHCR queries, image publishing
- `COSIGN_PRIVATE_KEY` (string, required): Private key for image signing
  - Format: PEM-encoded private key
  - Used for: Cosign signing step after rechunking

**Environment Variables** (workflow-level):
- `IMAGE_NAME` (string, constant): `"bazzite-dkub"`
- `IMAGE_REGISTRY` (string, constant): `"ghcr.io/dkolb"`

**Relationships**:
- **Provides**: Inputs to workflow steps (fresh-rechunk, secrets, environment)
- **Controls**: Prev-ref generation behavior
- **Determines**: Whether rechunking uses incremental or fresh mode

**State Transitions**:
1. **Triggered**: Workflow dispatched by event
2. **Initialized**: Context loaded from GitHub Actions environment
3. **Executing**: Steps consume context values
4. **Complete**: Workflow finishes (success or failure)

**Lifecycle**:
- **Created**: When workflow triggered
- **Exists**: Duration of workflow execution (~10-15 minutes)
- **Destroyed**: Workflow cleanup (automatic)

---

### Entity 6: BTRFS Storage Mount

**Description**: Ephemeral BTRFS filesystem mounted on GitHub Actions runner for rechunking intermediate storage.

**Attributes**:
- `mount_point` (string, constant): `/var/tmp/rechunk-btrfs`
  - Required by: hhd-dev/rechunk action configuration
- `size_gb` (number, constant): `50` (gigabytes)
  - Justification: Accommodates full image (~10 GB) + intermediate files (~15 GB) + safety margin
  - Source: research Decision 3
- `filesystem_type` (string, constant): `"btrfs"`
  - Required by: hhd-dev/rechunk (uses BTRFS copy-on-write features)
- `loopback_device` (string, computed): Loop device path
  - Example: `/dev/loop0`
  - Created by: `losetup` or `mount -o loop`
- `image_file` (string, constant): `/var/tmp/rechunk.img`
  - Sparse file containing BTRFS filesystem
  - Created by: `truncate -s 50G`

**Creation Steps**:
```bash
1. Create directory: sudo mkdir -p /var/tmp/rechunk-btrfs
2. Create sparse file: sudo truncate -s 50G /var/tmp/rechunk.img
3. Format BTRFS: sudo mkfs.btrfs /var/tmp/rechunk.img
4. Mount filesystem: sudo mount -o loop /var/tmp/rechunk.img /var/tmp/rechunk-btrfs
5. Set permissions: sudo chmod 777 /var/tmp/rechunk-btrfs
```

**State Transitions**:
1. **Creating**: Sparse file and filesystem being created
2. **Mounted**: Filesystem accessible at mount point
3. **In Use**: hhd-dev/rechunk writing intermediate files
4. **Unmounted**: (Automatic during runner cleanup)

**Relationships**:
- **Required by**: hhd-dev/rechunk action
- **Provides**: Storage for rechunking workspace
- **Consumed**: Disk space on GitHub Actions runner

**Lifecycle**:
- **Created**: During "Mount BTRFS Storage" workflow step
- **Exists**: Until workflow completes
- **Destroyed**: GitHub Actions runner cleanup (automatic, no manual unmount needed)

**Validation Rules**:
- Mount point must be writable (777 permissions)
- Filesystem must be BTRFS (hhd-dev/rechunk validates)
- Available space must be ≥50 GB

**Failure Scenarios**:
- **Disk space exhausted**: If runner has <60 GB free, mount fails
- **BTRFS tools unavailable**: If mkfs.btrfs missing, workflow fails
- **Permissions error**: If chmod fails, rechunk action cannot write

**Resource Constraints**:
- GitHub Actions ubuntu-latest runners: ~14 GB RAM, ~84 GB disk (as of 2025)
- BTRFS mount consumes ~50 GB of 84 GB available
- Sufficient headroom for other workflow steps

---

## Data Flow

```
1. GitHub Actions Trigger
   ↓
2. Build Pre-Rechunk OCI Image
   ↓
3. Mount BTRFS Storage (Entity 6)
   ↓
4. Generate Version Tag (40-YYYYMMDD)
   ↓
5. Query GHCR for Previous Reference (Entity 3)
   │  - Check fresh-rechunk input (Entity 5)
   │  - Query GHCR tags with skopeo
   │  - Filter for ^40-[0-9]{8}$ pattern
   │  - Return latest tag or empty
   ↓
6. Run Rechunker (hhd-dev/rechunk)
   │  Input: Pre-Rechunk Image (Entity 1)
   │  Input: Previous Reference (Entity 3)
   │  Input: OCI Labels (Entity 4)
   │  Storage: BTRFS Mount (Entity 6)
   │  Output: Post-Rechunk Image (Entity 2)
   ↓
7. Load Rechunked Image into Podman
   ↓
8. Push to GHCR
   ↓
9. Sign with Cosign
   │  Input: Post-Rechunk Image (Entity 2)
   │  Input: COSIGN_PRIVATE_KEY (Entity 5)
   ↓
10. Published Rechunked Image in GHCR
```

## Validation & Constraints

### Cross-Entity Validation

- **Pre-rechunk → Post-rechunk size**: Post-rechunk initial download size should be similar to pre-rechunk (delta optimization is transparent)
- **Prev-ref → Current tag**: Prev-ref tag must differ from current build tag (prevent circular reference)
- **Labels consistency**: OCI labels from pre-rechunk must be preserved in post-rechunk (rechunk action reapplies)
- **BTRFS → Rechunk success**: Rechunking step requires BTRFS mount to succeed (dependency validation)

### Integrity Constraints

- **Tag uniqueness**: Version tags are unique per date (one build per day per tag format)
- **Label completeness**: All required OCI labels must be present in published image
- **Signature validity**: Cosign signature must verify against published image
- **GHCR consistency**: Published image manifest digest must match signed digest

### Performance Constraints

- **Rechunking time**: Entity 2 creation must complete in <8 minutes (SC-002)
- **BTRFS space**: Entity 6 must provide ≥50 GB (accommodate largest expected images)
- **Total workflow time**: End-to-end workflow must complete in <20 minutes (GitHub Actions best practice)

## Summary

This data model represents a **workflow pipeline** rather than traditional persistent application data. Entities are ephemeral (workflow execution artifacts) or metadata (OCI labels). The primary persistent artifacts are:

- **Rechunked OCI Images** in GHCR (Entity 2)
- **OCI Labels** embedded in image manifests (Entity 4)

All other entities exist only during workflow execution. This aligns with the feature's scope: a CI/CD pipeline enhancement with no runtime state or user data management.
